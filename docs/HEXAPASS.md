# HexaPass — 구독형 멤버십 & 예약 시스템 (학습형 OOP 프로젝트)

## 📋 프로젝트 개요

HexaPass는 헬스장, 스터디룸, 온라인 강의 등 다양한 **구독형 멤버십과 예약 시스템**을 일반화한 도메인을 다루는 학습형 프로젝트입니다. 순수 자바 OOP를 기반으로 설계·리팩토링·패턴·아키텍처를 단계적으로 익히고, 이후 스프링/영속성/테스트로 확장하는 것을 목표로 합니다.

### 🎯 학습 목표
- **도메인 주도 설계(DDD)**: 값 객체(Value Object)와 엔티티(Entity) 구분, 애그리게잇, 불변식
- **객체지향 설계 원칙**: SOLID 원칙 실무 적용
- **디자인 패턴**: 전략, 데코레이터, 상태, 템플릿 메서드, 팩토리, 사양(Specification) 패턴
- **아키텍처 패턴**: 헥사고날 아키텍처(포트와 어댑터)
- **동시성과 트랜잭션**: 경쟁 조건, 락킹, 트랜잭션 경계
- **테스트 주도 개발(TDD)**: 단위 테스트, 통합 테스트
- **문서화**: ADR(Architecture Decision Record)

## 🏗️ 프로젝트 구조

```
hexapass/
 ├─ docs/                         # 📄 프로젝트 문서
 │   ├─ requirements.md           # 요구사항 명세서
 │   ├─ glossary.md              # 도메인 용어집
 │   ├─ refactoring-notes.md     # 리팩토링 과정 기록
 │   ├─ STEP1.md                 # 1단계 상세 가이드
 │   └─ adr/                     # Architecture Decision Records
 ├─ src/main/java/com/hexapass/
 │   ├─ domain/                   # 🏛️ 도메인 계층 (핵심 비즈니스 로직)
 │   │   ├─ common/              # 공통 값 객체 (Money, DateRange, Result 등)
 │   │   ├─ model/               # 도메인 모델 (Member, Reservation 등)
 │   │   ├─ policy/              # 정책 객체 (할인, 취소, 예약 조건)
 │   │   ├─ service/             # 도메인 서비스 (복잡한 비즈니스 규칙)
 │   │   └─ port/                # 아웃바운드 포트 (Repository, Payment 등)
 │   └─ cli/                     # 🖥️ CLI 애플리케이션 (초기 구동용)
 ├─ src/test/java/com/hexapass/  # 🧪 테스트 코드
 ├─ app-spring/                   # 🍃 스프링 모듈 (후반 단계)
 ├─ build.gradle                 # Gradle 빌드 설정
 ├─ settings.gradle              # Gradle 프로젝트 설정
 └─ README.md                    # 프로젝트 설명서
```

## 🔑 핵심 도메인 개념

### 1. 멤버십 시스템
- **회원(Member)**: 시스템 사용자, 멤버십 플랜 보유
- **멤버십 플랜(MembershipPlan)**: 월간/연간/기간제 등 다양한 구독 형태
- **등급 시스템**: 기본/프리미엄/VIP 등 등급별 혜택 차등

### 2. 예약 시스템
- **리소스(Resource)**: 예약 가능한 자원 (룸, 기구, 강의)
- **예약(Reservation)**: 특정 시간대의 리소스 이용 예약
- **스케줄(Schedule)**: 리소스별 이용 가능 시간표

### 3. 정책 시스템
- **할인 정책**: 정률, 정액, 기간, 쿠폰 등 다양한 할인 적용
- **취소 정책**: 시간대별 취소 수수료 차등 적용
- **예약 정책**: 동시 예약 제한, 시간 제약 등

## 🎓 선행 학습 개념

### 객체지향 설계 (OOP)
- **캡슐화**: 데이터와 행위를 하나의 객체로 묶고 외부 접근 제어
- **상속**: 기존 클래스의 속성과 메서드를 새 클래스가 물려받음
- **다형성**: 같은 인터페이스로 다른 구현체들을 동일하게 다룸
- **추상화**: 복잡한 구현 세부사항을 숨기고 핵심만 노출

### SOLID 원칙
- **SRP (Single Responsibility Principle)**: 한 클래스는 하나의 책임만
- **OCP (Open/Closed Principle)**: 확장에는 열려있고 수정에는 닫혀있게
- **LSP (Liskov Substitution Principle)**: 서브타입은 기반 타입으로 대체 가능해야
- **ISP (Interface Segregation Principle)**: 클라이언트는 사용하지 않는 인터페이스에 의존하면 안됨
- **DIP (Dependency Inversion Principle)**: 고수준 모듈은 저수준 모듈에 의존하면 안됨

### 도메인 주도 설계 (DDD)
- **값 객체(Value Object)**: 식별자가 없고 값 자체가 의미인 객체 (Money, DateRange)
- **엔티티(Entity)**: 고유한 식별자를 가지고 생명주기가 있는 객체 (Member, Reservation)
- **애그리게잇(Aggregate)**: 일관성 경계를 가지는 엔티티와 값 객체들의 묶음
- **도메인 서비스**: 특정 엔티티에 속하지 않는 도메인 로직
- **불변식(Invariant)**: 항상 참이어야 하는 비즈니스 규칙

### 디자인 패턴
- **전략 패턴(Strategy)**: 알고리즘 군을 정의하고 각각을 캡슐화하여 교체 가능하게 함
- **데코레이터 패턴(Decorator)**: 객체에 동적으로 새로운 책임을 추가
- **상태 패턴(State)**: 객체의 내부 상태에 따라 행위를 변경
- **템플릿 메서드 패턴**: 알고리즘의 구조는 유지하면서 특정 단계를 서브클래스에서 구현
- **팩토리 패턴(Factory)**: 객체 생성 로직을 캡슐화
- **사양 패턴(Specification)**: 비즈니스 규칙을 객체로 캡슐화하여 조합 가능하게 함

### 헥사고날 아키텍처
- **포트(Port)**: 애플리케이션과 외부 세계 사이의 인터페이스
- **어댑터(Adapter)**: 포트를 구현하는 구체적인 기술 (DB, Web, File 등)
- **인바운드 포트**: 애플리케이션으로 들어오는 요청 (Use Case, API)
- **아웃바운드 포트**: 애플리케이션에서 나가는 요청 (Repository, External Service)

### 동시성과 트랜잭션
- **경쟁 조건(Race Condition)**: 여러 스레드가 공유 자원에 동시 접근할 때 발생하는 문제
- **락킹(Locking)**: 공유 자원에 대한 동시 접근 제어
- **트랜잭션 경계**: 데이터 일관성을 보장하기 위한 작업 단위 설정
- **낙관적 락 vs 비관적 락**: 동시성 제어 방식의 차이

## 📚 8단계 학습 로드맵

### 1단계: 순수 OOP 도메인 모델링
- 핵심 도메인 모델 설계 (Member, Reservation, MembershipPlan)
- 값 객체 구현 (Money, DateRange, Period)
- 불변식과 유효성 검증
- 단위 테스트 작성

### 2단계: SOLID 기반 리팩토링
- 단일 책임 원칙 적용
- 개방-폐쇄 원칙으로 확장성 확보
- 의존성 역전으로 추상화 강화

### 3단계: 디자인 패턴 적용
- 전략 패턴으로 할인 정책 구현
- 데코레이터로 할인 조합 처리
- 상태 패턴으로 예약 상태 관리
- 사양 패턴으로 복잡한 조건 표현

### 4단계: 테스트 전략 & TDD
- Given-When-Then 구조의 테스트
- 경계값 테스트와 예외 시나리오
- 모킹과 스텁을 활용한 격리 테스트

### 5단계: 헥사고날 아키텍처
- 포트와 어댑터 분리
- 인메모리 구현으로 시작
- CLI 애플리케이션으로 동작 확인

### 6단계: 동시성 실험
- 동시 예약 경쟁 상황 시뮬레이션
- 락킹 전략 적용
- 트랜잭션 경계 설정

### 7단계: 스프링 도입
- 의존성 주입으로 포트 구현체 연결
- REST API 구현
- JPA로 영속성 계층 구축

### 8단계: 고급 주제
- CQRS 패턴 적용
- 도메인 이벤트 처리
- 성능 최적화

## 🚀 빠른 시작

```bash
# 1. 프로젝트 클론 또는 생성
git init
git add .
git commit -m "Initial project structure"

# 2. 문서 읽기 (필수!)
docs/requirements.md      # 요구사항 이해
docs/glossary.md         # 도메인 용어 학습  
docs/STEP1.md           # 1단계 상세 가이드

# 3. 첫 번째 값 객체 구현
# src/main/java/com/hexapass/domain/common/Money.java

# 4. 테스트 실행
./gradlew test
```

## 📖 권장 학습 순서

1. **docs/requirements.md** 읽고 도메인 이해
2. **docs/glossary.md**로 용어 정리
3. **docs/STEP1.md** 따라가며 첫 구현
4. 단계별로 커밋하며 진행
5. **docs/refactoring-notes.md**에 학습 내용 기록
6. **docs/adr/**에 설계 결정 사항 문서화

## ⚡ 핵심 학습 포인트

- **불변성 우선**: 세터 사용 금지, `withXxx()` 메서드로 복사본 생성
- **실패 빠르게**: 생성 시점에 유효성 검증, 불변식 보장
- **도메인 언어**: 비즈니스 용어를 그대로 코드에 반영
- **단위 테스트**: 모든 도메인 로직은 테스트로 검증
- **점진적 설계**: 완벽한 설계보다는 지속적인 리팩토링

---

**🎯 이 프로젝트를 통해 배우게 될 것들:**
- 실무에서 바로 사용 가능한 OOP 설계 능력
- 복잡한 비즈니스 로직을 깔끔하게 모델링하는 기법
- 변경에 유연한 아키텍처 구성 방법
- 테스트 가능한 코드 작성 방법
- 팀에서 소통 가능한 문서화 기법